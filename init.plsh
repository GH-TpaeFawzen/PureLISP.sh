;;;; list by atom variables

(def list (lambda a a))

;;;; logical functions

(def and (lambda (a b) (cond (a b) (t nil))))

(def or (lambda (a b) (cond (a t) (t b))))

(def not (lambda (a) (cond (a nil) (t t))))

(def null (lambda (a) (eq a nil)))

;;;; utility functions for list processing

(def append2
  (lambda (a b)
    (cond ((eq a nil) b)
          (t (cons (car a) (append2 (cdr a) b))))))

(def flatten
  (lambda (a)
    (cond ((eq a nil) nil)
          (t (append2 (car a) (flatten (cdr a)))))))

(def append (lambda a (flatten a)))

(def reverse
  (lambda (a)
    (cond ((null a) nil)
          (t (append (reverse (cdr a))
                     (list (car a)))))))

(def map
  (lambda (f a . b)
     (cond ((eq a nil) nil)
           ((eq b nil)
            (cons (f (car a))
                  (map f (cdr a))))
           (t
            (cons (f (car a) (car (car b)))
                  (map f (cdr a) (cdr (car b))))))))

(def pairs (lambda (a b) (map cons a b)))

(def assoc
  (lambda (k vs)
     (cond ((null vs) nil)
           ((eq (car (car vs)) k)
            (car vs))
           (t (assoc k (cdr vs))))))

(def member
  (lambda (k vs)
     (cond ((null vs) nil)
           ((eq (car vs) k) vs)
           (t (member k (cdr vs))))))

(def filter
  (lambda (f x)
     (cond ((null x) nil)
           ((f (car x))
            (cons (car x) (filter f (cdr x))))
           (t (filter f (cdr x))))))

(def reduce
  (lambda (f L i)
     (cond ((null L) i)
           (t (f (car L) (reduce f (cdr L) i))))))

;;;; lambda calculus

(def fix (lambda (f) (f (lambda (x) ((fix f) x)))))

;;;; conscell accessors

(def caar (lambda (x) (car (car x))))

(def cadr (lambda (x) (car (cdr x))))

(def cdar (lambda (x) (cdr (car x))))

(def cddr (lambda (x) (cdr (cdr x))))

